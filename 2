import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import json
from datetime import datetime

def analyze_complexity():
    """Анализ сложности реализации логистической системы"""
    
    print("АНАЛИЗ СЛОЖНОСТИ РЕАЛИЗАЦИИ ЛОГИСТИЧЕСКОЙ СИСТЕМЫ")
    print("=" * 60)

    # Подсчет сложности запросов для логистики
    postgres_join_query = """
SELECT s.tracking_number, s.status, s.weight, s.value,
       wf.name as from_warehouse, wt.name as to_warehouse,
       r.name as route_name
FROM shipments s
JOIN warehouses wf ON s.warehouse_from_id = wf.id
JOIN warehouses wt ON s.warehouse_to_id = wt.id
JOIN routes r ON s.route_id = r.id
WHERE s.status = %s
ORDER BY s.shipment_date DESC
LIMIT 100
""".strip().count('\n') + 1

    postgres_aggregation_query = """
SELECT status, COUNT(*) as count, AVG(weight) as avg_weight, 
       AVG(value) as avg_value, SUM(value) as total_value
FROM shipments 
GROUP BY status
ORDER BY count DESC
""".strip().count('\n') + 1

    # MongoDB агрегационные пайплайны
    mongodb_find_steps = 4  # find + projection + sort + limit
    mongodb_aggregation_steps = 5  # $match + $group + $project + $sort + $limit

    print(f"Сложность реализации логистических запросов:")
    print(f"• PostgreSQL JOIN запрос: {postgres_join_query} строк")
    print(f"• PostgreSQL агрегация: {postgres_aggregation_query} строк")
    print(f"• MongoDB поиск: {mongodb_find_steps} этапов")
    print(f"• MongoDB агрегация: {mongodb_aggregation_steps} этапов")

    # Анализ читаемости
    print(f"\nЧитаемость кода:")
    print(f"• PostgreSQL: Высокая (стандартный SQL, знакомый синтаксис)")
    print(f"• MongoDB: Средняя (требует знания агрегационных операторов)")

    # Анализ поддерживаемости
    print(f"\nПоддерживаемость:")
    print(f"• PostgreSQL: Легко модифицировать (изменение SQL запросов)")
    print(f"• MongoDB: Сложнее (изменение структуры пайплайнов)")

    # Анализ производительности
    print(f"\nПроизводительность:")
    print(f"• PostgreSQL: Оптимизированные JOIN операции, индексы")
    print(f"• MongoDB: Быстрые операции с документами, встроенные индексы")

    # Создание визуализации
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

    # График сложности запросов
    categories = ['JOIN запрос', 'Агрегация', 'Поиск', 'Сортировка']
    postgres_scores = [postgres_join_query, postgres_aggregation_query, 3, 2]
    mongodb_scores = [mongodb_find_steps, mongodb_aggregation_steps, 4, 3]

    x = np.arange(len(categories))
    width = 0.35

    bars1 = ax1.bar(x - width/2, postgres_scores, width, label='PostgreSQL', color='blue', alpha=0.7)
    bars2 = ax1.bar(x + width/2, mongodb_scores, width, label='MongoDB', color='orange', alpha=0.7)
    ax1.set_xlabel('Типы операций')
    ax1.set_ylabel('Сложность (строки/этапы)')
    ax1.set_title('Сравнение сложности реализации запросов')
    ax1.set_xticks(x)
    ax1.set_xticklabels(categories)
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Добавляем значения на столбцы
    for bar in bars1:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{int(height)}', ha='center', va='bottom')
    for bar in bars2:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{int(height)}', ha='center', va='bottom')

    # График производительности операций для логистики
    operations = ['Вставка данных', 'Поиск по индексу', 'Сложный JOIN', 'Агрегация', 'Обновление']
    pg_performance = [8, 9, 9, 8, 7]  # Оценка по 10-балльной шкале
    mongo_performance = [9, 8, 6, 7, 9]

    line1 = ax2.plot(operations, pg_performance, 'o-', label='PostgreSQL', linewidth=2, markersize=8, color='blue')
    line2 = ax2.plot(operations, mongo_performance, 's-', label='MongoDB', linewidth=2, markersize=8, color='orange')
    ax2.set_xlabel('Операции с данными')
    ax2.set_ylabel('Производительность (1-10)')
    ax2.set_title('Производительность операций в логистике')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, 10)

    # Добавляем значения на точки
    for i, (pg_val, mongo_val) in enumerate(zip(pg_performance, mongo_performance)):
        ax2.text(i, pg_val + 0.2, str(pg_val), ha='center', va='bottom', color='blue')
        ax2.text(i, mongo_val - 0.3, str(mongo_val), ha='center', va='top', color='orange')

    # График гибкости для логистики
    aspects = ['Схема данных', 'Масштабирование', 'Геоданные', 'Индексирование', 'Резервное копирование']
    pg_flexibility = [6, 7, 9, 9, 9]
    mongo_flexibility = [9, 8, 7, 8, 7]

    x_flex = np.arange(len(aspects))

    bars3 = ax3.bar(x_flex - width/2, pg_flexibility, width, label='PostgreSQL', color='blue', alpha=0.7)
    bars4 = ax3.bar(x_flex + width/2, mongo_flexibility, width, label='MongoDB', color='orange', alpha=0.7)
    ax3.set_xlabel('Аспекты системы')
    ax3.set_ylabel('Оценка гибкости (1-10)')
    ax3.set_title('Гибкость для логистической системы')
    ax3.set_xticks(x_flex)
    ax3.set_xticklabels(aspects, rotation=45, ha='right')
    ax3.legend()
    ax3.grid(True, alpha=0.3)

    # Добавляем значения на столбцы
    for bar in bars3:
        height = bar.get_height()
        ax3.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{int(height)}', ha='center', va='bottom')
    for bar in bars4:
        height = bar.get_height()
        ax3.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{int(height)}', ha='center', va='bottom')

    # Общая оценка для логистики
    overall_categories = ['Производительность', 'Гибкость', 'Надежность', 'Масштабируемость', 'Стоимость']
    pg_overall = [8.5, 6.5, 9.0, 7.5, 8.0]
    mongo_overall = [7.5, 8.5, 7.0, 8.5, 7.0]

    x_overall = np.arange(len(overall_categories))

    bars5 = ax4.bar(x_overall - width/2, pg_overall, width, label='PostgreSQL', color='blue', alpha=0.7)
    bars6 = ax4.bar(x_overall + width/2, mongo_overall, width, label='MongoDB', color='orange', alpha=0.7)
    ax4.set_xlabel('Критерии оценки')
    ax4.set_ylabel('Оценка (1-10)')
    ax4.set_title('Общая оценка для логистической системы')
    ax4.set_xticks(x_overall)
    ax4.set_xticklabels(overall_categories)
    ax4.legend()
    ax4.grid(True, alpha=0.3)

    # Добавляем значения на столбцы
    for bar in bars5:
        height = bar.get_height()
        ax4.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{height:.1f}', ha='center', va='bottom')
    for bar in bars6:
        height = bar.get_height()
        ax4.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                 f'{height:.1f}', ha='center', va='bottom')

    plt.tight_layout()
    plt.savefig('data/06_complexity_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Итоговые выводы для логистики
    print(f"\nИТОГОВЫЕ ВЫВОДЫ ДЛЯ ЛОГИСТИЧЕСКОЙ СИСТЕМЫ:")
    print(f"=" * 50)
    print(f"PostgreSQL лучше для логистики когда:")
    print(f"  • Требуются сложные JOIN между грузами, складами и маршрутами")
    print(f"  • Нужны транзакции для финансовых операций")
    print(f"  • Важна согласованность данных в реальном времени")
    print(f"  • Требуется аналитика с агрегациями")
    print(f"  • Работа с геоданными и пространственными запросами")

    print(f"\nMongoDB лучше для логистики когда:")
    print(f"  • Схема данных часто меняется (новые типы грузов, атрибуты)")
    print(f"  • Требуется горизонтальное масштабирование")
    print(f"  • Данные имеют иерархическую структуру")
    print(f"  • Нужна быстрая разработка прототипов")
    print(f"  • Операции в основном чтение с простыми фильтрами")

    print(f"\nРекомендации для логистических систем:")
    print(f"  • Для трекинга грузов: PostgreSQL (JOIN запросы)")
    print(f"  • Для аналитики доставки: PostgreSQL (агрегации)")
    print(f"  • Для мобильного приложения: MongoDB (гибкая схема)")
    print(f"  • Для больших объемов данных: оба в зависимости от паттернов доступа")
    print(f"  • Для enterprise-систем: PostgreSQL (надежность и ACID)")

    # Сохранение анализа
    complexity_analysis = {
        'analysis_time': datetime.now().isoformat(),
        'complexity_metrics': {
            'postgresql_join_lines': postgres_join_query,
            'postgresql_aggregation_lines': postgres_aggregation_query,
            'mongodb_find_steps': mongodb_find_steps,
            'mongodb_aggregation_steps': mongodb_aggregation_steps
        },
        'performance_scores': {
            'postgresql': pg_performance,
            'mongodb': mongo_performance
        },
        'flexibility_scores': {
            'postgresql': pg_flexibility,
            'mongodb': mongo_flexibility
        },
        'overall_scores': {
            'postgresql': pg_overall,
            'mongodb': mongo_overall
        }
    }

    with open('data/06_complexity_analysis.json', 'w', encoding='utf-8') as f:
        json.dump(complexity_analysis, f, ensure_ascii=False, indent=2)

    print("\nАнализ сложности сохранен в data/06_complexity_analysis.json")

if __name__ == "__main__":
    analyze_complexity()
