import psycopg2
from pymongo import MongoClient
import time
import json
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

def measure_time(func, *args, **kwargs):
    """Измерение времени выполнения функции"""
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    return result, end_time - start_time

def get_mongo_client():
    """Получение подключения к MongoDB с аутентификацией"""
    try:
        # Пробуем с аутентификацией (самый вероятный вариант)
        client = MongoClient(
            'mongodb://mongouser:mongopass@localhost:27017/',
            serverSelectionTimeoutMS=2000
        )
        client.admin.command('ping')
        print("Успешное подключение к MongoDB")
        return client
    except:
        try:
            # Пробуем через имя сервиса в Docker с аутентификацией
            client = MongoClient(
                'mongodb://mongouser:mongopass@mongodb:27017/',
                serverSelectionTimeoutMS=2000
            )
            client.admin.command('ping')
            print("Успешное подключение к MongoDB через Docker сервис")
            return client
        except:
            try:
                # Пробуем без аутентификации (на случай если она отключена)
                client = MongoClient('mongodb://localhost:27017/', serverSelectionTimeoutMS=2000)
                client.admin.command('ping')
                print("Успешное подключение к MongoDB без аутентификации")
                return client
            except:
                # Не выводим ошибку, просто возвращаем None
                return None

def get_postgres_shipments_by_weight(weight_threshold):
    """Получение грузов по весу в PostgreSQL"""
    conn_params = {
        "dbname": "studpg",
        "user": "postgres",
        "password": "changeme", 
        "host": "postgresql",
        "port": "5432"
    }
    
    try:
        conn = psycopg2.connect(**conn_params)
        with conn.cursor() as cur:
            cur.execute("""
                SELECT s.tracking_number, s.weight, s.value, wf.city, wt.city
                FROM shipments s
                JOIN warehouses wf ON s.warehouse_from_id = wf.id
                JOIN warehouses wt ON s.warehouse_to_id = wt.id  
                WHERE s.weight > %s
                ORDER BY s.weight DESC
                LIMIT 100
            """, (weight_threshold,))
            return cur.fetchall()
    except Exception as e:
        print(f"Ошибка PostgreSQL: {e}")
        return []
    finally:
        if 'conn' in locals():
            conn.close()

def get_mongodb_shipments_by_weight(weight_threshold):
    """Получение грузов по весу в MongoDB"""
    mongo_client = get_mongo_client()
    if not mongo_client:
        return []
    
    try:
        # Получаем базу данных с аутентификацией
        db = mongo_client['studmongo']
        # Проверяем доступ к коллекции
        results = list(db.shipments.find(
            {"weight": {"$gt": weight_threshold}},
            {
                "tracking_number": 1,
                "weight": 1,
                "value": 1,
                "warehouse_from.city": 1,
                "warehouse_to.city": 1
            }
        ).sort("weight", -1).limit(100))
        return results
    except Exception as e:
        print(f"Ошибка доступа к MongoDB: {e}")
        return []
    finally:
        mongo_client.close()

def get_postgres_shipments_by_city(city):
    """Получение грузов по городу назначения в PostgreSQL"""
    conn_params = {
        "dbname": "studpg",
        "user": "postgres",
        "password": "changeme", 
        "host": "postgresql",
        "port": "5432"
    }
    
    try:
        conn = psycopg2.connect(**conn_params)
        with conn.cursor() as cur:
            cur.execute("""
                SELECT s.tracking_number, s.status, s.weight, wf.name, wt.name
                FROM shipments s
                JOIN warehouses wf ON s.warehouse_from_id = wf.id
                JOIN warehouses wt ON s.warehouse_to_id = wt.id
                WHERE wt.city = %s
                ORDER BY s.shipment_date DESC
                LIMIT 100
            """, (city,))
            return cur.fetchall()
    except Exception as e:
        print(f"Ошибка PostgreSQL: {e}")
        return []
    finally:
        if 'conn' in locals():
            conn.close()

def get_mongodb_shipments_by_city(city):
    """Получение грузов по городу назначения в MongoDB"""
    mongo_client = get_mongo_client()
    if not mongo_client:
        return []
    
    try:
        db = mongo_client['studmongo']
        results = list(db.shipments.find(
            {"warehouse_to.city": city},
            {
                "tracking_number": 1,
                "status": 1,
                "weight": 1,
                "warehouse_from.name": 1,
                "warehouse_to.name": 1
            }
        ).sort("shipment_date", -1).limit(100))
        return results
    except Exception as e:
        print(f"Ошибка доступа к MongoDB: {e}")
        return []
    finally:
        mongo_client.close()

def get_postgres_aggregation():
    """Агрегация данных в PostgreSQL"""
    conn_params = {
        "dbname": "studpg",
        "user": "postgres",
        "password": "changeme", 
        "host": "postgresql",
        "port": "5432"
    }
    
    try:
        conn = psycopg2.connect(**conn_params)
        with conn.cursor() as cur:
            cur.execute("""
                SELECT 
                    status,
                    COUNT(*) as count,
                    AVG(weight) as avg_weight,
                    AVG(value) as avg_value,
                    SUM(value) as total_value
                FROM shipments 
                GROUP BY status
                ORDER BY count DESC
            """)
            return cur.fetchall()
    except Exception as e:
        print(f"Ошибка PostgreSQL: {e}")
        return []
    finally:
        if 'conn' in locals():
            conn.close()

def get_mongodb_aggregation():
    """Агрегация данных в MongoDB"""
    mongo_client = get_mongo_client()
    if not mongo_client:
        return []
    
    try:
        db = mongo_client['studmongo']
        pipeline = [
            {"$group": {
                "_id": "$status",
                "count": {"$sum": 1},
                "avg_weight": {"$avg": "$weight"},
                "avg_value": {"$avg": "$value"},
                "total_value": {"$sum": "$value"}
            }},
            {"$sort": {"count": -1}}
        ]
        results = list(db.shipments.aggregate(pipeline))
        return results
    except Exception as e:
        print(f"Ошибка доступа к MongoDB: {e}")
        return []
    finally:
        mongo_client.close()

# Сравнение производительности PostgreSQL и MongoDB
print("СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ ЛОГИСТИЧЕСКИХ СИСТЕМ")
print("=" * 60)

# Проверяем доступность подключений
print("Проверка подключений...")
print("PostgreSQL подключен")

mongo_client = get_mongo_client()
mongo_available = mongo_client is not None

if mongo_available:
    print("MongoDB доступен для тестирования")
else:
    print("MongoDB недоступен, тестируем только PostgreSQL")

# Тестирование разных весовых категорий
test_weights = [100, 300, 500, 700, 900]
postgres_times = []
mongodb_times = []

print(f"\nТЕСТИРОВАНИЕ ЗАПРОСОВ ПО ВЕСУ ГРУЗОВ")

for weight in test_weights:
    print(f"\nТест: Грузы тяжелее {weight}кг:")
    
    # PostgreSQL
    _, pg_time = measure_time(get_postgres_shipments_by_weight, weight)
    postgres_times.append(pg_time)
    print(f"  PostgreSQL: {pg_time:.4f} сек")
    
    # MongoDB (только если доступен)
    if mongo_available:
        _, mongo_time = measure_time(get_mongodb_shipments_by_weight, weight)
        mongodb_times.append(mongo_time)
        print(f"  MongoDB: {mongo_time:.4f} сек")
        
        # Сравнение
        if pg_time > 0 and mongo_time > 0:
            if pg_time < mongo_time:
                faster = "PostgreSQL"
                speedup = mongo_time / pg_time
            else:
                faster = "MongoDB"
                speedup = pg_time / mongo_time
            
            print(f"  Быстрее: {faster} (в {speedup:.2f} раз)")
        else:
            print(f"  Невозможно сравнить")
    else:
        mongodb_times.append(0)
        print(f"  MongoDB: --")

# Визуализация результатов
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

plt.figure(figsize=(12, 8))

# График времени выполнения
plt.subplot(2, 2, 1)
plt.plot(test_weights, postgres_times, 'o-', label='PostgreSQL', linewidth=2, markersize=8)

if mongo_available and any(t > 0 for t in mongodb_times):
    plt.plot(test_weights, mongodb_times, 's-', label='MongoDB', linewidth=2, markersize=8)

plt.xlabel('Вес груза (кг)')
plt.ylabel('Время выполнения (секунды)')
plt.title('Время выполнения запросов по весу груза')
plt.legend()
plt.grid(True, alpha=0.3)

# График соотношения производительности (только если MongoDB доступен и есть данные)
plt.subplot(2, 2, 2)
valid_pairs = [(pg, mongo) for pg, mongo in zip(postgres_times, mongodb_times) if pg > 0 and mongo > 0]

if mongo_available and len(valid_pairs) > 0:
    speedup_ratio = [mongo_time / pg_time for pg_time, mongo_time in valid_pairs]
    valid_weights = [test_weights[i] for i, (pg, mongo) in enumerate(zip(postgres_times, mongodb_times)) if pg > 0 and mongo > 0]
    
    plt.bar(range(len(valid_weights)), speedup_ratio, color=['green' if x > 1 else 'red' for x in speedup_ratio])
    plt.xlabel('Вес груза (кг)')
    plt.ylabel('Соотношение времени (MongoDB/PostgreSQL)')
    plt.title('Соотношение производительности')
    plt.xticks(range(len(valid_weights)), valid_weights)
    plt.axhline(y=1, color='black', linestyle='--', alpha=0.5)
    plt.grid(True, alpha=0.3)
else:
    plt.text(0.5, 0.5, 'MongoDB недоступен\nдля сравнения', 
             ha='center', va='center', fontsize=12,
             bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray", alpha=0.7))
    plt.axis('off')

# Статистика
plt.subplot(2, 2, 3)
avg_pg_time = np.mean([t for t in postgres_times if t > 0])
std_pg_time = np.std([t for t in postgres_times if t > 0])

databases = ['PostgreSQL']
avg_times = [avg_pg_time]
std_times = [std_pg_time]

if mongo_available and any(t > 0 for t in mongodb_times):
    avg_mongo_time = np.mean([t for t in mongodb_times if t > 0])
    std_mongo_time = np.std([t for t in mongodb_times if t > 0])
    databases.append('MongoDB')
    avg_times.append(avg_mongo_time)
    std_times.append(std_mongo_time)

bars = plt.bar(databases, avg_times, yerr=std_times, capsize=5, color=['blue', 'orange'][:len(databases)])
plt.ylabel('Среднее время выполнения (секунды)')
plt.title('Средняя производительность')
plt.grid(True, alpha=0.3)

# Добавляем значения на столбцы
for bar, avg, std in zip(bars, avg_times, std_times):
    plt.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.01,
            f'{avg:.4f}±{std:.4f}', ha='center', va='bottom', fontsize=9)

# Выводы
plt.subplot(2, 2, 4)
plt.axis('off')

# Тестируем дополнительные запросы для выводов
print(f"\nДОПОЛНИТЕЛЬНЫЕ ТЕСТЫ:")

# Тест по городам
cities = ['Москва', 'Санкт-Петербург']
city_pg_times = []
city_mongo_times = []

for city in cities:
    _, pg_time = measure_time(get_postgres_shipments_by_city, city)
    city_pg_times.append(pg_time)
    
    if mongo_available:
        _, mongo_time = measure_time(get_mongodb_shipments_by_city, city)
        city_mongo_times.append(mongo_time)
        if mongo_time > 0:
            print(f"  Город {city}: PostgreSQL {pg_time:.4f}с, MongoDB {mongo_time:.4f}с")
        else:
            print(f"  Город {city}: PostgreSQL {pg_time:.4f}с, MongoDB --")
    else:
        print(f"  Город {city}: PostgreSQL {pg_time:.4f}с")

# Тест агрегации
_, pg_agg_time = measure_time(get_postgres_aggregation)

if mongo_available:
    _, mongo_agg_time = measure_time(get_mongodb_aggregation)
    if mongo_agg_time > 0:
        print(f"  Агрегация: PostgreSQL {pg_agg_time:.4f}с, MongoDB {mongo_agg_time:.4f}с")
    else:
        print(f"  Агрегация: PostgreSQL {pg_agg_time:.4f}с, MongoDB --")
else:
    print(f"  Агрегация: PostgreSQL {pg_agg_time:.4f}с")

# Формируем текст выводов
if mongo_available and any(t > 0 for t in mongodb_times):
    conclusion_text = f"""
АНАЛИЗ РЕЗУЛЬТАТОВ ЛОГИСТИЧЕСКОЙ СИСТЕМЫ:

Средняя производительность:
• PostgreSQL: {avg_pg_time:.4f} ± {std_pg_time:.4f} сек
• MongoDB: {avg_mongo_time:.4f} ± {std_mongo_time:.4f} сек

Общее соотношение:
• PostgreSQL быстрее в {avg_mongo_time/avg_pg_time:.2f} раз
• Стабильность: {'PostgreSQL' if std_pg_time < std_mongo_time else 'MongoDB'}

Рекомендации для логистики:
• Для фильтрации по весу: {'PostgreSQL' if avg_pg_time < avg_mongo_time else 'MongoDB'}
• Для поиска по городам: {'PostgreSQL' if np.mean(city_pg_times) < np.mean([t for t in city_mongo_times if t > 0]) else 'MongoDB'}
• Для агрегаций: {'PostgreSQL' if pg_agg_time < mongo_agg_time else 'MongoDB'}
"""
else:
    conclusion_text = f"""
АНАЛИЗ РЕЗУЛЬТАТОВ ЛОГИСТИЧЕСКОЙ СИСТЕМЫ:

Производительность PostgreSQL:
• Среднее время: {avg_pg_time:.4f} ± {std_pg_time:.4f} сек
• Стабильность: хорошая

Рекомендации:
• MongoDB недоступен для сравнения
• PostgreSQL показал стабильную производительность
• Для логистических запросов рекомендуется PostgreSQL
"""

plt.text(0.1, 0.5, conclusion_text, fontsize=10, verticalalignment='center',
         bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.8))

plt.tight_layout()
plt.savefig('data/05_performance_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

# Детальная статистика
print(f"\nДЕТАЛЬНАЯ СТАТИСТИКА:")
print(f"PostgreSQL - Среднее: {avg_pg_time:.4f}с, Стд. отклонение: {std_pg_time:.4f}с")

if mongo_available and any(t > 0 for t in mongodb_times):
    print(f"MongoDB - Среднее: {avg_mongo_time:.4f}с, Стд. отклонение: {std_mongo_time:.4f}с")
    print(f"Общее ускорение PostgreSQL: {avg_mongo_time/avg_pg_time:.2f}x")

# Сохранение результатов
performance_results = {
    'comparison_time': datetime.now().isoformat(),
    'mongo_available': mongo_available,
    'mongo_working': mongo_available and any(t > 0 for t in mongodb_times),
    'weight_tests': {
        'weights': test_weights,
        'postgresql_times': postgres_times,
        'mongodb_times': mongodb_times if mongo_available else []
    },
    'statistics': {
        'postgresql_avg': avg_pg_time,
        'postgresql_std': std_pg_time,
        'mongodb_avg': avg_mongo_time if mongo_available and any(t > 0 for t in mongodb_times) else 0,
        'mongodb_std': std_mongo_time if mongo_available and any(t > 0 for t in mongodb_times) else 0
    }
}

with open('data/05_performance_results.json', 'w', encoding='utf-8') as f:
    json.dump(performance_results, f, ensure_ascii=False, indent=2)

print("Результаты сохранены в data/05_performance_results.json")

if mongo_client:
    mongo_client.close()
