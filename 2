%pip install hdfs
!pwd
-------------------------
import os
import subprocess
import pandas as pd

# Загрузка данных из HDFS
print("Загрузка данных из HDFS...")

# Путь к данным в HDFS (правильный путь)
hdfs_path = "/user/hadoop/input/myfile.csv"
local_path = "/opt/myfile.csv"

# Скачиваем файл из HDFS
try:
    # Команда для скачивания из HDFS
    hdfs_download_cmd = f"hdfs dfs -get {hdfs_path} {local_path}"
    print(f"Выполнение команды: {hdfs_download_cmd}")
    
    # Задаем JAVA_HOME, так как Jupyter может его не видеть
    env = dict(os.environ, **{'JAVA_HOME': '/usr/lib/jvm/java-11-openjdk-amd64'})
    result = subprocess.run(hdfs_download_cmd, shell=True, capture_output=True, text=True, cwd="/opt", env=env)
    
    if result.returncode == 0:
        print(f"Данные успешно загружены из HDFS: {hdfs_path}")
    else:
        print(f"Ошибка при загрузке из HDFS: {result.stderr}")
        print("Попытка найти файл локально...")
        local_path = "/opt/data/myfile.csv"
        
    # Проверяем наличие файла
    if not os.path.exists(local_path):
        print(f"Файл не найден в {local_path}. Используем альтернативный путь...")
        local_path = "myfile.csv"
        
except Exception as e:
    print(f"Ошибка при выполнении subprocess: {e}")
    print("Попытка использовать локальный файл...")
    local_path = "/opt/data/myfile.csv"

# Проверяем наличие файла перед загрузкой
if not os.path.exists(local_path):
    print("Файл не найден. Пробуем последний вариант...")
    local_path = "myfile.csv"

# Финальная проверка и загрузка данных
if os.path.exists(local_path):
    df = pd.read_csv(local_path, low_memory=False)
    print(f"Размер датасета: {df.shape}")
    print(f"Данные успешно загружены из {local_path}")
    print(df.head())
else:
    print(f"ОШИБКА: Файл myfile.csv не найден!")
    print(f"Искали по следующим путям:")
    print(f"  - /opt/myfile.csv (из HDFS)")
    print(f"  - /opt/data/myfile.csv (локальный)")
    print(f"  - myfile.csv (в текущей директории)")
    df = pd.DataFrame()  # Создаем пустой DataFrame чтобы не было ошибки











------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import subprocess
import os

# Настройка отображения
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")
%matplotlib inline

# Увеличение размера графиков
plt.rcParams['figure.figsize'] = (12, 8)

# Загрузка данных
print("Загрузка данных о продажах...")
data_file = '/opt/data/myfile.csv'

# Проверяем наличие файла
if os.path.exists(data_file):
    df = pd.read_csv(data_file, low_memory=False)
    print(f"Данные успешно загружены из {data_file}")
    print(f"Размер датасета: {df.shape}")
else:
    print(f"ОШИБКА: Файл {data_file} не найден!")
    df = pd.DataFrame()


    ---------------------------------------

    # Очистка данных
df_clean = df.copy()

# Удаляем отмененные заказы (InvoiceNo начинается с 'c')
df_clean = df_clean[~df_clean['InvoiceNo'].astype(str).str.startswith('C', na=False)]

# Удаляем возвраты (отрицательное количество)
df_clean = df_clean[df_clean['Quantity'] > 0]

# Удаляем строки с пропущенными Description (названиями товаров)
df_clean = df_clean.dropna(subset=['Description'])

# Преобразуем Quantity в числовой формат и удаляем пропуски
df_clean['Quantity'] = pd.to_numeric(df_clean['Quantity'], errors='coerce')
df_clean = df_clean.dropna(subset=['Quantity'])

# Удаляем возможные выбросы (очень большие количества)
Q1 = df_clean['Quantity'].quantile(0.25)
Q3 = df_clean['Quantity'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
df_clean = df_clean[(df_clean['Quantity'] >= lower_bound) & (df_clean['Quantity'] <= upper_bound)]

print(f"Количество строк после очистки: {len(df_clean)}")
print(f"Количество уникальных товаров: {df_clean['Description'].nunique()}")
print(f"Топ-5 самых продаваемых товаров:")
print(df_clean['Description'].value_counts().head())

# Продолжение анализа...
